{
    "docs": [
        {
            "location": "/", 
            "text": "Zero bugs, Zero hassle.\n\n\nCurrent Status: \nalpha prototype\n. We need your input!\n\n\nJavaScript is getting more and more popular every day. However, the dynamic aspect of JavaScript often makes it difficult to correctly write and maintain complex applications.\n\n\nMany efforts have been made to create new, safer languages that compile \nto\n JavaScript. While many of these languages are designed very well, the fact is \nmost people already know JavaScript\n, and are not so inclined to learn a new language to do the same things JavaScript can do.\n\n\nJS Zero\n is a \nES6-compatible, proper subset\n of JavaScript that aims to be functional and type-safe for doing I/O in web applications.\n\n\nWhy JS Zero?\n\n\n\n\u2009\u2009+--------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+---------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+--------------+\n\u2009\u2009|\u2009\u2009Input\u2009\u2009     |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009 JS Zero      |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009Output\u2009    \u2009|\n\u2009\u2009|  (HTTP)\u2009 \u2009  \u2009|------\n\u2009|\u2009 (Valid ES6)  |------\n\u2009|  (JSON\u2009API)  |\n\u2009\u2009|\u2009\u2009(Database)\u2009\u2009|\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009(type safe)\u2009 |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009(HTML)\u2009\u2009    |\n\u2009\u2009+--------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+---------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+--------------+\n\n\n\n\n\nMuch of programming in web development today is \n\"data in, data out\"\n. That is, given some data sources, we write programs to combine / aggregate / transform that data, then output the result.\n\n\nJavaScript Zero fills this niche; it tries to make writing such programs bug-free, using a \ntypesafe, compatible subset\n of the ubiquitous language of the web.\n\n\nVision \n Goals\n\n\nJS Zero has three main goals:\n\n\n\n\nSpecify a stricter, ES6-compatible, proper subset of JavaScript\n\n\nDesign and build a type system that can type check this subset soundly\n\n\nAs a developer tool, remain easy and seamless to use and understand.\n\n\n\n\nWith these goals complete, JS Zero will help you significantly towards writing bug-free programs.\n\n\nMotivating Example\n\n\nLet's pretend you're making an app that allows a user to enter their \nGitHub username\n and receive back the \ntotal number of lines\n written across their repositories. This will involve using \nGitHub's API\n.\n\n\nAt this point, JS Zero already provides \na key feature\n to help us:\n\n\n\n\nWe must \ndeclare the types\n of the data we will get from the GitHub API. This is a reasonable requirement, since there is no way JS Zero can infer what kind of data GitHub will return.\n\n\n\n\nBecause JS Zero must be valid JavaScript, we must declare these types \nin code\n. Here is what type declarations for the above example would like:\n\n\n// Although GitHub returns much more data,\n// we only need to declare the data shapes we care about.\n//\nlet Repo = Object.ofType({ id: Number, name: String, languages_url: String })\nlet Languages = Map.ofType(String, Number)\n\n\n\n\nAs mentioned, the type of an API request cannot be inferred. That's ok; we can tell JS Zero to \nassume\n the type of a function instead of type checking the function's body. This means JS Zero will \ntrust\n that our type declaration is correct.\n\n\nIn our example, we tell JS Zero to \nassume\n specific types for our API calls:\n\n\n// Pretend `HTTP` is a library that returns a promise\n\n$assume `fetchRepos : (String) =\n Promise( Array(Repo) )`\n\nfunction fetchRepos (user) {\n  return HTTP.get('http://api.github.com/users/' + user + '/repos')\n}\n\n\n$assume `fetchLangs : (Repo) =\n Promise( Array(Language) )`\n\nfunction fetchLangs (repo) {\n  // Be careful! The above `$assume` means no type checking\n  // will be done for the body of this function.\n\n  return HTTP.get(repo.languages_url).then(function(langs) {\n    var keyValPairs = Object.keys(langs).map( k =\n [k, langs[k]] )\n    return new Map(keyValPairs)\n  })\n}\n\n\n\n\nNow that we've declared the types of our HTTP requests, we can \nsafely\n make use of them:\n\n\n// Note how there are NO TYPE DECLARATIONS in the following code!\n\nmyFormElement.addEventListener('submit', function(e) {\n  e.preventDefault();\n\n  fetchRepo(this.githubUsername.value)\n\n    .then(function(repos) {\n      // This line doesn't type check - r.language_url is not a property!\n      // var promises = repos.map(r =\n fetchLangs(r.language_url));\n\n      var promises = repos.map(r =\n fetchLangs(r.languages_url));\n      return Promise.all(promises);\n    })\n\n    .then(function(repoLanguages) {\n      // At this point, `repoLanguages` is an Array of Languages.\n      // In other words, it has the concrete type: Array( Map(String, Number) ).\n      // If that slipped by you, no problem. JS Zero has got you covered.\n\n      var totalLineCount = repoLanguages\n                           .map(langs =\n langs.values().reduce(add))\n                           .reduce(add)\n      ;\n      alert(\nYou have written \n + totalLineCount + \n lines of code!\n);\n    })\n  ;\n});\n\nfunction add (x, y) { return x + y; }\n\n\n\n\nAs you can see, once you annotate your boundaries (HTTP in this case), no further type declarations are necessary. The idea is, you record the shape of your data once, and then safely forget about it.\n\n\nIntegrating with Other JS Code\n\n\nAlthough all JS Zero code is valid JavaScript code, not all JavaScript code is valid Zero code. If you want your code to be type safe, sometimes you will have to annotate 3rd party libraries.\n\n\nAs it turns out, \n$assume\n is an easy way to do this if you only need a function or two. For example, let's say you want to use the \nmarked\n npm package to render some markdown:\n\n\n$assume `marked : (String) =\n String`\nvar marked = require('marked')\n\nconsole.log( marked('I am using __markdown__.') )\n\n\n\n\nOn the other hand, if you're importing a larger library, you might need to write annotations yourself (assuming someone else has not already). For example, if you want to use \nReact.js\n to handle your views, the type declarations might look something like this:\n\n\nType.module('react', function () {\n  let VirtualElement = Type.new()\n  let Attrs = Option.ofType( Object )\n  let Child = Type.Union(String, VirtualElement)\n\n  return {\n    createElement: Function.multi(\n      `(String)                  =\n VirtualElement`,\n      `(String, Attrs)           =\n VirtualElement`,\n      `(String, Attrs, ...Child) =\n VirtualElement`\n    ),\n    render: `(VirtualElement, DomElement) =\n Void`\n  }\n})\nvar React = require('react')\n\n// All type safe!\nReact.render(\n  React.createElement('h1', null, 'Hello, world!'),\n  document.getElementById('.my-div')\n)\n\n\n\n\nMost of the JSZ methods and types (\nType.module\n, \n$assume\n etc.) don't do any runtime computation; they are only there to inform the type checker in a fully ES6-compatible manner.\n\n\nInterested?\n\n\nJS Zero is only in its design phase. If want JS Zero to happen, here are some ways you can help:\n\n\n\n\nContribute to or star the \nGitHub repo\n,\n\n\nHelp spread the word with a \nretweet\n, or a \ntweet of your own\n,\n\n\nShow your support / interest\n by making a quick post \nto this thread\n (easy GitHub login)\n\n\nOr \njoin the detailed discussion\n and influence the direction of the project!", 
            "title": "Home"
        }, 
        {
            "location": "/#zero-bugs-zero-hassle", 
            "text": "Current Status:  alpha prototype . We need your input!  JavaScript is getting more and more popular every day. However, the dynamic aspect of JavaScript often makes it difficult to correctly write and maintain complex applications.  Many efforts have been made to create new, safer languages that compile  to  JavaScript. While many of these languages are designed very well, the fact is  most people already know JavaScript , and are not so inclined to learn a new language to do the same things JavaScript can do.  JS Zero  is a  ES6-compatible, proper subset  of JavaScript that aims to be functional and type-safe for doing I/O in web applications.", 
            "title": "Zero bugs, Zero hassle."
        }, 
        {
            "location": "/#why-js-zero", 
            "text": "+--------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+---------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+--------------+\n\u2009\u2009|\u2009\u2009Input\u2009\u2009     |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009 JS Zero      |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009Output\u2009    \u2009|\n\u2009\u2009|  (HTTP)\u2009 \u2009  \u2009|------ \u2009|\u2009 (Valid ES6)  |------ \u2009|  (JSON\u2009API)  |\n\u2009\u2009|\u2009\u2009(Database)\u2009\u2009|\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009(type safe)\u2009 |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009(HTML)\u2009\u2009    |\n\u2009\u2009+--------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+---------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+--------------+  Much of programming in web development today is  \"data in, data out\" . That is, given some data sources, we write programs to combine / aggregate / transform that data, then output the result.  JavaScript Zero fills this niche; it tries to make writing such programs bug-free, using a  typesafe, compatible subset  of the ubiquitous language of the web.", 
            "title": "Why JS Zero?"
        }, 
        {
            "location": "/#vision-goals", 
            "text": "JS Zero has three main goals:   Specify a stricter, ES6-compatible, proper subset of JavaScript  Design and build a type system that can type check this subset soundly  As a developer tool, remain easy and seamless to use and understand.   With these goals complete, JS Zero will help you significantly towards writing bug-free programs.", 
            "title": "Vision &amp; Goals"
        }, 
        {
            "location": "/#motivating-example", 
            "text": "Let's pretend you're making an app that allows a user to enter their  GitHub username  and receive back the  total number of lines  written across their repositories. This will involve using  GitHub's API .  At this point, JS Zero already provides  a key feature  to help us:   We must  declare the types  of the data we will get from the GitHub API. This is a reasonable requirement, since there is no way JS Zero can infer what kind of data GitHub will return.   Because JS Zero must be valid JavaScript, we must declare these types  in code . Here is what type declarations for the above example would like:  // Although GitHub returns much more data,\n// we only need to declare the data shapes we care about.\n//\nlet Repo = Object.ofType({ id: Number, name: String, languages_url: String })\nlet Languages = Map.ofType(String, Number)  As mentioned, the type of an API request cannot be inferred. That's ok; we can tell JS Zero to  assume  the type of a function instead of type checking the function's body. This means JS Zero will  trust  that our type declaration is correct.  In our example, we tell JS Zero to  assume  specific types for our API calls:  // Pretend `HTTP` is a library that returns a promise\n\n$assume `fetchRepos : (String) =  Promise( Array(Repo) )`\n\nfunction fetchRepos (user) {\n  return HTTP.get('http://api.github.com/users/' + user + '/repos')\n}\n\n\n$assume `fetchLangs : (Repo) =  Promise( Array(Language) )`\n\nfunction fetchLangs (repo) {\n  // Be careful! The above `$assume` means no type checking\n  // will be done for the body of this function.\n\n  return HTTP.get(repo.languages_url).then(function(langs) {\n    var keyValPairs = Object.keys(langs).map( k =  [k, langs[k]] )\n    return new Map(keyValPairs)\n  })\n}  Now that we've declared the types of our HTTP requests, we can  safely  make use of them:  // Note how there are NO TYPE DECLARATIONS in the following code!\n\nmyFormElement.addEventListener('submit', function(e) {\n  e.preventDefault();\n\n  fetchRepo(this.githubUsername.value)\n\n    .then(function(repos) {\n      // This line doesn't type check - r.language_url is not a property!\n      // var promises = repos.map(r =  fetchLangs(r.language_url));\n\n      var promises = repos.map(r =  fetchLangs(r.languages_url));\n      return Promise.all(promises);\n    })\n\n    .then(function(repoLanguages) {\n      // At this point, `repoLanguages` is an Array of Languages.\n      // In other words, it has the concrete type: Array( Map(String, Number) ).\n      // If that slipped by you, no problem. JS Zero has got you covered.\n\n      var totalLineCount = repoLanguages\n                           .map(langs =  langs.values().reduce(add))\n                           .reduce(add)\n      ;\n      alert( You have written   + totalLineCount +   lines of code! );\n    })\n  ;\n});\n\nfunction add (x, y) { return x + y; }  As you can see, once you annotate your boundaries (HTTP in this case), no further type declarations are necessary. The idea is, you record the shape of your data once, and then safely forget about it.", 
            "title": "Motivating Example"
        }, 
        {
            "location": "/#integrating-with-other-js-code", 
            "text": "Although all JS Zero code is valid JavaScript code, not all JavaScript code is valid Zero code. If you want your code to be type safe, sometimes you will have to annotate 3rd party libraries.  As it turns out,  $assume  is an easy way to do this if you only need a function or two. For example, let's say you want to use the  marked  npm package to render some markdown:  $assume `marked : (String) =  String`\nvar marked = require('marked')\n\nconsole.log( marked('I am using __markdown__.') )  On the other hand, if you're importing a larger library, you might need to write annotations yourself (assuming someone else has not already). For example, if you want to use  React.js  to handle your views, the type declarations might look something like this:  Type.module('react', function () {\n  let VirtualElement = Type.new()\n  let Attrs = Option.ofType( Object )\n  let Child = Type.Union(String, VirtualElement)\n\n  return {\n    createElement: Function.multi(\n      `(String)                  =  VirtualElement`,\n      `(String, Attrs)           =  VirtualElement`,\n      `(String, Attrs, ...Child) =  VirtualElement`\n    ),\n    render: `(VirtualElement, DomElement) =  Void`\n  }\n})\nvar React = require('react')\n\n// All type safe!\nReact.render(\n  React.createElement('h1', null, 'Hello, world!'),\n  document.getElementById('.my-div')\n)  Most of the JSZ methods and types ( Type.module ,  $assume  etc.) don't do any runtime computation; they are only there to inform the type checker in a fully ES6-compatible manner.", 
            "title": "Integrating with Other JS Code"
        }, 
        {
            "location": "/#interested", 
            "text": "JS Zero is only in its design phase. If want JS Zero to happen, here are some ways you can help:   Contribute to or star the  GitHub repo ,  Help spread the word with a  retweet , or a  tweet of your own ,  Show your support / interest  by making a quick post  to this thread  (easy GitHub login)  Or  join the detailed discussion  and influence the direction of the project!", 
            "title": "Interested?"
        }, 
        {
            "location": "/examples/", 
            "text": "Motivating Examples\n\n\nSimple Array of Models\n\n\n// @type Person = { name: String, age: Number }\n\n// @assume fetchPeople : () =\n Promise(Array(Person), HttpError)\nfunction fetchPeople () {\n  return HTTP.get('http://api.example.com/people');\n}\n\n// Here we safely use fetchPeople without the need for further type annotations.\nfetchPeople()\n  .then(function(people) {\n    var names = people.map(p =\n p.name);\n    var ageSum = people.map(p =\n p.age).reduce(add);\n\n    // Won't pass: Person has no `hobby` property\n    // var hobbies = people.map(p =\n p.hobby);\n\n    // Creating an array in this fashion indicates a Tuple type.\n    return Array(names.length, ageSum);\n  })\n  .then(function([nameCount, ageSum]) {\n    console.log(\n# of names:\n, nameCount);\n    console.log(\nSum of ages:\n, ageSum);\n\n    // Won't pass: number is not a function\n    // ageSum()\n  });\n\nfunction add (x, y) { return x + y }", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#motivating-examples", 
            "text": "", 
            "title": "Motivating Examples"
        }, 
        {
            "location": "/examples/#simple-array-of-models", 
            "text": "// @type Person = { name: String, age: Number }\n\n// @assume fetchPeople : () =  Promise(Array(Person), HttpError)\nfunction fetchPeople () {\n  return HTTP.get('http://api.example.com/people');\n}\n\n// Here we safely use fetchPeople without the need for further type annotations.\nfetchPeople()\n  .then(function(people) {\n    var names = people.map(p =  p.name);\n    var ageSum = people.map(p =  p.age).reduce(add);\n\n    // Won't pass: Person has no `hobby` property\n    // var hobbies = people.map(p =  p.hobby);\n\n    // Creating an array in this fashion indicates a Tuple type.\n    return Array(names.length, ageSum);\n  })\n  .then(function([nameCount, ageSum]) {\n    console.log( # of names: , nameCount);\n    console.log( Sum of ages: , ageSum);\n\n    // Won't pass: number is not a function\n    // ageSum()\n  });\n\nfunction add (x, y) { return x + y }", 
            "title": "Simple Array of Models"
        }, 
        {
            "location": "/faq/", 
            "text": "FAQ\n\n\nHow does JS Zero differ from TypeScript?\n\n\nTypeScript\n aims to be a \nsuperset\n of JavaScript, while JS Zero aims to be a \nsubset\n. This means TypeScript \nextends\n the JS language, while JS Zero \nrefines\n the language by removing features that are hard to check for correctness.\n\n\nHow does JS Zero differ from Flowtype?\n\n\nFlowtype\n and JS Zero are indeed very similar. However, Flowtype aims to type check the \nentire JavaScript language\n. Unfortunately, JavaScript as a whole is too dynamic for Flowtype to achieve full type safety. JS Zero aims to specify a \nsubset\n of JavaScript that can be type checked \nsoundly\n.\n\n\nFlow describes itself as \nopt-in\n; it doesn't check your code until you tell it to. To contrast, JS Zero is \nopt-out\n; it tries to check everything, but it's easy to tell it not to. Not only does this better allow for sound typing, but it also makes it easy to write and annotate your own dynamic functions that integrate seamlessly with the rest of the type system.", 
            "title": "Faq"
        }, 
        {
            "location": "/faq/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#how-does-js-zero-differ-from-typescript", 
            "text": "TypeScript  aims to be a  superset  of JavaScript, while JS Zero aims to be a  subset . This means TypeScript  extends  the JS language, while JS Zero  refines  the language by removing features that are hard to check for correctness.", 
            "title": "How does JS Zero differ from TypeScript?"
        }, 
        {
            "location": "/faq/#how-does-js-zero-differ-from-flowtype", 
            "text": "Flowtype  and JS Zero are indeed very similar. However, Flowtype aims to type check the  entire JavaScript language . Unfortunately, JavaScript as a whole is too dynamic for Flowtype to achieve full type safety. JS Zero aims to specify a  subset  of JavaScript that can be type checked  soundly .  Flow describes itself as  opt-in ; it doesn't check your code until you tell it to. To contrast, JS Zero is  opt-out ; it tries to check everything, but it's easy to tell it not to. Not only does this better allow for sound typing, but it also makes it easy to write and annotate your own dynamic functions that integrate seamlessly with the rest of the type system.", 
            "title": "How does JS Zero differ from Flowtype?"
        }, 
        {
            "location": "/spec/", 
            "text": "Specification\n\n\nThis document specifies exactly what parts of ES6 will be included in the JS Zero subset, as well as type declaration syntax and usage.\n\n\nThis is a \nvery\n rough draft. Please see discussion threads for latest details.\n\n\nGoals\n\n\n\n\nStay close to primitive types\n\n\nObjects, arrays, functions, strings, numbers, booleans, maps, and sets should cover almost all use cases.\n\n\nOnly require type annotations at \nboundaries\n\n\nDatabase queries, HTTP requests, etc.\n\n\n\n\nAnti-Goals\n\n\nHere are some things JS Zero is NOT trying to do:\n\n\n\n\nChange the existing behavior of JavaScript\n\n\nExplanation: If a semantic doesn't fit JS Zero, it should be \nremoved\n (but never changed)\n\n\nForce all code to be \npure\n\n\nExplanation: JavaScript is not designed to be a pure language. Forcing it to be so would not be worth the effort.\n\n\nRequire knowledge of advanced type-theory to effectively use JS Zero\n\n\nExplanation: JS Zero is designed to be used by the average JavaScript developer.\n\n\n\n\nSpecific Features\n\n\n(incomplete) This is the subset of features you will be able to write in JavaScript Zero:\n\n\n\n\nlet, var, const\n\n\nBasic types (objects, arrays, strings, numbers, booleans)\n\n\nFunctions - anonymous, declarations, arrow\n\n\nSymbols\n\n\nPromises\n\n\nMap / Set\n\n\nPrototypes\n\n\n\n\nThese features will be \nomitted\n:\n\n\n\n\nNo classes, no keyword \nnew\n\n\nNo double equals \n==\n\n\n\n\nBuilt-in Types\n\n\nJS Zero several basic types...\n\n\nString\nNumber\nBoolean\nObject\nFunction\nSymbol\n\n\n\n\n...and several higher-kinded types...\n\n\nArray(elem)\nPromise(resolved, rejected)\nMap(key, value)\nSet(elem)\n\n\n\n\nType Annotation Syntax\n\n\nHere are some examples of type annotations:\n\n\n$ensure `num : Number`\nvar num = 101;\n\n$ensure `str : String`\nvar str = \nhello\n;\n\n$ensure `nums : Array(Number)`\nvar nums = [10, 20];\n\n$ensure `obj : { x: Number, y: String }`\nvar obj = { x: 11, y: 'twenty-two' }\n\n$ensure `inc : (Number) =\n Number`\nfunction inc (num) {\n  return num + 1;\n}\n\n$ensure `add : (Number, Number) =\n Number`\nfunction add (x, y) {\n  return x + y + 1;\n}\n\n$ensure `favFoods : () =\n Array(String)`\nfunction favFoods () {\n  return ['bananas', 'cherries', 'potatoes'];\n}\n\n$ensure `wrap : (a) =\n Array(a)`\nfunction wrap (value) {\n  return [value];\n}\n\n\nvar React = require('react')\n\n$ensure `withLayout : (React.VirtualElement) =\n React.VirtualElement`\nfunction withLayout (contents) {\n  return React.createElement('div', { class: 'layout' }, contents)\n}\n\n\n\n\nThe key point to recognize is that a function type annotation takes the form \n(inputs...) =\n output\n. The annotations make use of (or look very similar to) \nES6 arrow functions\n, except that parenthesis around the inputs are always required.\n\n\nType Aliases\n\n\nTo declare a type alias, simply construct it from existing types. This creates an alias that is no different than the type you set it to.\n\n\nlet Venue = Object.ofType({ name: String, rating: Number })\n\n\n\n\nAssumptions\n\n\nWhen working with IO, many times you will be reading data from some external source. In these cases you don't want JS Zero to attempt (and fail) at determining your types. Instead, you want to use \n$assume\n to explicitly declare what types your incoming data will be.\n\n\nlet Pet = Object.ofType({ name: String, happiness: Number })\n\n$assume `fetchPets : (Number) =\n Promise( Array(Pet) )`\nfunction fetchPets (minHappiness) {\n  return knex.select('*').from('pets').where('happiness', '\n', minHappiness)\n}\n\n\n\n\nEnsures\n\n\nAlthough not required, you can annotate any JS Zero function using \n@ensure\n and force the type system to \nenforce\n the function follows the type you specify.\n\n\n$ensure `multiplyString : (Number, String) =\n String`\nfunction multiplyString (times, str) {\n  return new Array(times).fill(str); // oops, forgot to join the strings together!\n}\n\n\n\n\nIn the above example, JS Zero would normally infer has the type \n(Number, String) =\n Array(String)\n for \nmultiplyString\n (see docs for \nArray.fill\n). However, since we annotated our intended type with \n@ensure\n, JS Zero will instead throw a type error :)\n\n\nCustom Types\n\n\nTo declare an entirely new type, use the \nType.new\n builder. This is useful for creating your own custom types when declaring modules (explained in the next section).\n\n\nFor example, here is how you create an opaque type:\n\n\nlet VirtualElement = Type.new()\n$assume `React.render : (String, Object) =\n VirtualElement`\n\n\n\n\nA new type is only considered equal to itself, even if its structure is the same as another type's structure. For example:\n\n\nlet Person = Object.ofType({ name: String })\nlet Book   = Object.ofType({ name: String })\n\nlet Person2 = Type.new({ name: String })\n\n\n\n\nEven though \nPerson\n and \nPerson2\n are structurally the same, they are not considered equal; \nPerson2\n is a type distinctly different from \n{ name: String }\n. In contrast, type \nPerson\n and \nBook\n are both type \naliases\n, and thus considered the same type.\n\n\nA more advanced example\n\n\nlet Tree = Type.new(`|v|\n  Node({ value: v, left: Tree, right: Tree })\n  Leaf({ value: v })\n`)\n\nlet Node = Tree.Node\nlet Leaf = Tree.Leaf\n\nlet mySmallTree = Leaf(42)\n\nlet myBiggerTree = Node(\n  'the root',\n  Node(\n    'left child',\n    Leaf('leaf 1'),\n    Leaf('leaf 2'),\n  ),\n\n  Node(\n    'right child',\n    Leaf('leaf 3'),\n    Leaf('leaf 4'),\n  ),\n)\n\nmyBiggerTree.right.left.value //=\n 'leaf 3'\n\n\n\n\nThe above code will have the following inferred types:\n\n\nNode         : (a, Tree, Tree)                         =\n Tree(a)\n             \n ({ value: a, left: Tree, right: Tree }) =\n Tree(a)\n\nLeaf         : (a)            =\n Tree(a)\n             \n ({ value: a }) =\n Tree(a)\nmySmallTree  : Tree(Num)\nmyBiggerTree : Tree(String)\n\n\n\nType Prototypes\n\n\nIn an ideal world, JavaScript would be all functions and no \nthis\n. But, this is not the case, so we must make do. Because JavaScript has no \npipeline operator\n, we must rely on \nJavaScript prototypes\n to create fluid interfaces that are still type-sound without additional annotations.\n\n\nlet Person = Type.new({ name: String, hobby: String })\n  .withPrototype({\n    updateHobby: function (newHobby) {\n      return Person.let(this, { hobby: newHobby })\n    },\n    greet: function () {\n      return `${this.name} says \nHi! I like ${this.newHobby}\n`\n    }\n  })\n\nlet alice = Person.new('Alice', 'programming')\n\n//\n// All type-safe!\n//\nalice.updateHobby('stargazing').greet()\n//=\n 'Alice says \nHi! I like stargazing\n'\n\n\n\n\nNotice how \nupdateHobby('stargazing')\n and \ngreet()\n require no type annotations. This is because \nalice\n is inferred to be of type \nPerson\n, due to the assignment on the line before.\n\n\nFunctional Methods\n\n\nWhen you declare a type prototype, you not only get to use the prototype methods, but also the \nfunctional methods\n for free:\n\n\nlet Person = Type.new({ name: String, hobby: String })\n  .withPrototype({\n    updateHobby: function (newHobby) {\n      return Person.let(this, { hobby: newHobby })\n    },\n    greet: function () {\n      return `${this.name} says \nHi! I like ${this.newHobby}\n`\n    }\n  })\n\nlet alice = Person.new('Alice', 'programming')\nlet bob   = Person.new('Bob', 'gaming')\n\nPerson.greet(alice) //=\n 'Alice says \nHi! I like programming\n'\n\nlet greetings = [alice, bob].map( Person.greet )\n//=\n ['Alice says \nHi! I like programming\n', 'Bob says \nHi! I like gaming\n']\n\n\n\n\nAs you can see, \nPerson.greet\n is a function that takes its subject as an argument, as opposed to having to use \nalice.greet()\n. This is convenient for passing methods into other functions (as shown above with \nmap\n), and also partial application (as shown below):\n\n\n// `papp` stands for 'partial application'\nlet updatedPeople = [alice, bob].map( Person.updateHobby.papp('chillin') )\n\n\n\n\nNote how \nPerson.updateHobby\n takes its subject \nlast\n; this is to make functional methods partial-application friendly.\n\n\nTypes as Annotations\n\n\nSometimes the type of an object is not known to the compiler. For example, in the followng code, the \nshoutGreet\n function would not know its parameter should be of type \nPerson\n:\n\n\nlet Person = Type.new({ name: String, hobby: String })\n  .withPrototype({\n    greet: function () {\n      return `${this.name} says \nHi! I like ${this.newHobby}\n`\n    }\n  })\n\nlet shoutGreet = (person) =\n\n  person.greet().toUpperCase() // Type error!\n\n\n\n\nIn the above example, JS Zero will complain about \nperson.greet()\n, since it does not know the type of \nperson\n. Fortunately, it's easy to fix this; just use your \ntype as an annotation\n:\n\n\nlet shoutGreet = (person) =\n\n  Person(person).greet().toUpperCase() // All good :D\n\n\n\n\nThis is an intended restriction, to keep the type system fast, and to keep your code more readable. With that in mind, if you want your code to work with \nany\n type that has a \n.greet()\n function, you can use the \nType.Poly\n annotation:\n\n\nlet shoutGreet = (person) =\n\n  Type.Poly(person).greet().toUpperCase()\n\nlet alice = Person.new('Alice', 'programming')\n\nshoutGreet(alice) // OK\nshoutGreet({ greet: () =\n 'hi' }) // Also OK\nshoutGreet({ greet: () =\n 43 })   // Type Error! :)\n\n\n\n\nPrelude\n\n\nAside from type checking, JS Zero aims to also give a good toolset for typed functional programming.\n\n\nOptional\n\n\nOptional\n is a type that represents an optional value. It's the type you get when you use default parameters. For example:\n\n\n// This function has type: (Number, Optional(Number)) =\n Number\nlet add = (a, b=10) =\n a + b;\n\n\n\n\nResult\n\n\nThe \nResult\n type is a handy tool for representing an operation which may or not fail. If successful, you get an \nOk\n enum containing the successful value. If not, you get an \nErr\n enum containing the error. It's kind of like a synchronous Promise.\n\n\nHere's an example:\n\n\nlet { Ok, Err } = Result\nlet User = Object.ofType({ username: String, password: String })\n\n$ensure `createUser : (User) =\n Result(User, String)`\n\nlet createUser = (user) =\n\n  Ok(user)\n    .then( validateUsername )\n    .then( validatePassword )\n\nlet validateUsername = (user) =\n\n  /^[a-z]+$/.test(user.username) ? Ok(user) : Err('Invalid username')\n\nlet validatePassword = (user) =\n\n  user.password.length \n 0 ? Ok(user) : Err('Invalid password')\n\n// This will console log: 'Invalid username'\ncreateUser({ username: 'n00b', password: '123' })\n  .then( user =\n console.log(\nValidated user:\n, user) )\n  .catch( err =\n console.log(err) )\n\n\n\n\nModule Declarations\n\n\nTo safely and effectively use a large library, you or someone else might need to write a larger number of type declarations. You can do so using \nType.module\n:\n\n\nType.module('jquery', function () {\n\n  // Names of concrete types must be capitalized\n  let JQueryObject = Type.new()\n    .withPrototype({\n      on: `(String, DomEventHandler) =\n jQueryObject`,\n      show: `(String) =\n jQueryObject`,\n      hide: `(String) =\n jQueryObject`\n    })\n\n  return {\n    _this_: `(String) =\n JQueryObject`,\n    ajax: `({ type: String, url: String }) =\n Promise(?)`\n  }\n})\n\nvar $ = require('jquery');\n\n$('#app')        //=\n JQueryObject\n$('#app').show() //=\n JQueryObject\n\n$.ajax({ type: 'GET', url: 'http://api.example.com' })\n  .then(function (data) {\n    $assume `data : Array({ name: String })` // Annotate your boundary!\n    return data.map( p =\n p.name )\n  })", 
            "title": "Spec"
        }, 
        {
            "location": "/spec/#specification", 
            "text": "This document specifies exactly what parts of ES6 will be included in the JS Zero subset, as well as type declaration syntax and usage.  This is a  very  rough draft. Please see discussion threads for latest details.", 
            "title": "Specification"
        }, 
        {
            "location": "/spec/#goals", 
            "text": "Stay close to primitive types  Objects, arrays, functions, strings, numbers, booleans, maps, and sets should cover almost all use cases.  Only require type annotations at  boundaries  Database queries, HTTP requests, etc.", 
            "title": "Goals"
        }, 
        {
            "location": "/spec/#anti-goals", 
            "text": "Here are some things JS Zero is NOT trying to do:   Change the existing behavior of JavaScript  Explanation: If a semantic doesn't fit JS Zero, it should be  removed  (but never changed)  Force all code to be  pure  Explanation: JavaScript is not designed to be a pure language. Forcing it to be so would not be worth the effort.  Require knowledge of advanced type-theory to effectively use JS Zero  Explanation: JS Zero is designed to be used by the average JavaScript developer.", 
            "title": "Anti-Goals"
        }, 
        {
            "location": "/spec/#specific-features", 
            "text": "(incomplete) This is the subset of features you will be able to write in JavaScript Zero:   let, var, const  Basic types (objects, arrays, strings, numbers, booleans)  Functions - anonymous, declarations, arrow  Symbols  Promises  Map / Set  Prototypes   These features will be  omitted :   No classes, no keyword  new  No double equals  ==", 
            "title": "Specific Features"
        }, 
        {
            "location": "/spec/#built-in-types", 
            "text": "JS Zero several basic types...  String\nNumber\nBoolean\nObject\nFunction\nSymbol  ...and several higher-kinded types...  Array(elem)\nPromise(resolved, rejected)\nMap(key, value)\nSet(elem)", 
            "title": "Built-in Types"
        }, 
        {
            "location": "/spec/#type-annotation-syntax", 
            "text": "Here are some examples of type annotations:  $ensure `num : Number`\nvar num = 101;\n\n$ensure `str : String`\nvar str =  hello ;\n\n$ensure `nums : Array(Number)`\nvar nums = [10, 20];\n\n$ensure `obj : { x: Number, y: String }`\nvar obj = { x: 11, y: 'twenty-two' }\n\n$ensure `inc : (Number) =  Number`\nfunction inc (num) {\n  return num + 1;\n}\n\n$ensure `add : (Number, Number) =  Number`\nfunction add (x, y) {\n  return x + y + 1;\n}\n\n$ensure `favFoods : () =  Array(String)`\nfunction favFoods () {\n  return ['bananas', 'cherries', 'potatoes'];\n}\n\n$ensure `wrap : (a) =  Array(a)`\nfunction wrap (value) {\n  return [value];\n}\n\n\nvar React = require('react')\n\n$ensure `withLayout : (React.VirtualElement) =  React.VirtualElement`\nfunction withLayout (contents) {\n  return React.createElement('div', { class: 'layout' }, contents)\n}  The key point to recognize is that a function type annotation takes the form  (inputs...) =  output . The annotations make use of (or look very similar to)  ES6 arrow functions , except that parenthesis around the inputs are always required.  Type Aliases  To declare a type alias, simply construct it from existing types. This creates an alias that is no different than the type you set it to.  let Venue = Object.ofType({ name: String, rating: Number })  Assumptions  When working with IO, many times you will be reading data from some external source. In these cases you don't want JS Zero to attempt (and fail) at determining your types. Instead, you want to use  $assume  to explicitly declare what types your incoming data will be.  let Pet = Object.ofType({ name: String, happiness: Number })\n\n$assume `fetchPets : (Number) =  Promise( Array(Pet) )`\nfunction fetchPets (minHappiness) {\n  return knex.select('*').from('pets').where('happiness', ' ', minHappiness)\n}  Ensures  Although not required, you can annotate any JS Zero function using  @ensure  and force the type system to  enforce  the function follows the type you specify.  $ensure `multiplyString : (Number, String) =  String`\nfunction multiplyString (times, str) {\n  return new Array(times).fill(str); // oops, forgot to join the strings together!\n}  In the above example, JS Zero would normally infer has the type  (Number, String) =  Array(String)  for  multiplyString  (see docs for  Array.fill ). However, since we annotated our intended type with  @ensure , JS Zero will instead throw a type error :)  Custom Types  To declare an entirely new type, use the  Type.new  builder. This is useful for creating your own custom types when declaring modules (explained in the next section).  For example, here is how you create an opaque type:  let VirtualElement = Type.new()\n$assume `React.render : (String, Object) =  VirtualElement`  A new type is only considered equal to itself, even if its structure is the same as another type's structure. For example:  let Person = Object.ofType({ name: String })\nlet Book   = Object.ofType({ name: String })\n\nlet Person2 = Type.new({ name: String })  Even though  Person  and  Person2  are structurally the same, they are not considered equal;  Person2  is a type distinctly different from  { name: String } . In contrast, type  Person  and  Book  are both type  aliases , and thus considered the same type.  A more advanced example  let Tree = Type.new(`|v|\n  Node({ value: v, left: Tree, right: Tree })\n  Leaf({ value: v })\n`)\n\nlet Node = Tree.Node\nlet Leaf = Tree.Leaf\n\nlet mySmallTree = Leaf(42)\n\nlet myBiggerTree = Node(\n  'the root',\n  Node(\n    'left child',\n    Leaf('leaf 1'),\n    Leaf('leaf 2'),\n  ),\n\n  Node(\n    'right child',\n    Leaf('leaf 3'),\n    Leaf('leaf 4'),\n  ),\n)\n\nmyBiggerTree.right.left.value //=  'leaf 3'  The above code will have the following inferred types:  Node         : (a, Tree, Tree)                         =  Tree(a)\n               ({ value: a, left: Tree, right: Tree }) =  Tree(a)\n\nLeaf         : (a)            =  Tree(a)\n               ({ value: a }) =  Tree(a)\nmySmallTree  : Tree(Num)\nmyBiggerTree : Tree(String)", 
            "title": "Type Annotation Syntax"
        }, 
        {
            "location": "/spec/#type-prototypes", 
            "text": "In an ideal world, JavaScript would be all functions and no  this . But, this is not the case, so we must make do. Because JavaScript has no  pipeline operator , we must rely on  JavaScript prototypes  to create fluid interfaces that are still type-sound without additional annotations.  let Person = Type.new({ name: String, hobby: String })\n  .withPrototype({\n    updateHobby: function (newHobby) {\n      return Person.let(this, { hobby: newHobby })\n    },\n    greet: function () {\n      return `${this.name} says  Hi! I like ${this.newHobby} `\n    }\n  })\n\nlet alice = Person.new('Alice', 'programming')\n\n//\n// All type-safe!\n//\nalice.updateHobby('stargazing').greet()\n//=  'Alice says  Hi! I like stargazing '  Notice how  updateHobby('stargazing')  and  greet()  require no type annotations. This is because  alice  is inferred to be of type  Person , due to the assignment on the line before.", 
            "title": "Type Prototypes"
        }, 
        {
            "location": "/spec/#functional-methods", 
            "text": "When you declare a type prototype, you not only get to use the prototype methods, but also the  functional methods  for free:  let Person = Type.new({ name: String, hobby: String })\n  .withPrototype({\n    updateHobby: function (newHobby) {\n      return Person.let(this, { hobby: newHobby })\n    },\n    greet: function () {\n      return `${this.name} says  Hi! I like ${this.newHobby} `\n    }\n  })\n\nlet alice = Person.new('Alice', 'programming')\nlet bob   = Person.new('Bob', 'gaming')\n\nPerson.greet(alice) //=  'Alice says  Hi! I like programming '\n\nlet greetings = [alice, bob].map( Person.greet )\n//=  ['Alice says  Hi! I like programming ', 'Bob says  Hi! I like gaming ']  As you can see,  Person.greet  is a function that takes its subject as an argument, as opposed to having to use  alice.greet() . This is convenient for passing methods into other functions (as shown above with  map ), and also partial application (as shown below):  // `papp` stands for 'partial application'\nlet updatedPeople = [alice, bob].map( Person.updateHobby.papp('chillin') )  Note how  Person.updateHobby  takes its subject  last ; this is to make functional methods partial-application friendly.", 
            "title": "Functional Methods"
        }, 
        {
            "location": "/spec/#types-as-annotations", 
            "text": "Sometimes the type of an object is not known to the compiler. For example, in the followng code, the  shoutGreet  function would not know its parameter should be of type  Person :  let Person = Type.new({ name: String, hobby: String })\n  .withPrototype({\n    greet: function () {\n      return `${this.name} says  Hi! I like ${this.newHobby} `\n    }\n  })\n\nlet shoutGreet = (person) = \n  person.greet().toUpperCase() // Type error!  In the above example, JS Zero will complain about  person.greet() , since it does not know the type of  person . Fortunately, it's easy to fix this; just use your  type as an annotation :  let shoutGreet = (person) = \n  Person(person).greet().toUpperCase() // All good :D  This is an intended restriction, to keep the type system fast, and to keep your code more readable. With that in mind, if you want your code to work with  any  type that has a  .greet()  function, you can use the  Type.Poly  annotation:  let shoutGreet = (person) = \n  Type.Poly(person).greet().toUpperCase()\n\nlet alice = Person.new('Alice', 'programming')\n\nshoutGreet(alice) // OK\nshoutGreet({ greet: () =  'hi' }) // Also OK\nshoutGreet({ greet: () =  43 })   // Type Error! :)", 
            "title": "Types as Annotations"
        }, 
        {
            "location": "/spec/#prelude", 
            "text": "Aside from type checking, JS Zero aims to also give a good toolset for typed functional programming.  Optional  Optional  is a type that represents an optional value. It's the type you get when you use default parameters. For example:  // This function has type: (Number, Optional(Number)) =  Number\nlet add = (a, b=10) =  a + b;  Result  The  Result  type is a handy tool for representing an operation which may or not fail. If successful, you get an  Ok  enum containing the successful value. If not, you get an  Err  enum containing the error. It's kind of like a synchronous Promise.  Here's an example:  let { Ok, Err } = Result\nlet User = Object.ofType({ username: String, password: String })\n\n$ensure `createUser : (User) =  Result(User, String)`\n\nlet createUser = (user) = \n  Ok(user)\n    .then( validateUsername )\n    .then( validatePassword )\n\nlet validateUsername = (user) = \n  /^[a-z]+$/.test(user.username) ? Ok(user) : Err('Invalid username')\n\nlet validatePassword = (user) = \n  user.password.length   0 ? Ok(user) : Err('Invalid password')\n\n// This will console log: 'Invalid username'\ncreateUser({ username: 'n00b', password: '123' })\n  .then( user =  console.log( Validated user: , user) )\n  .catch( err =  console.log(err) )", 
            "title": "Prelude"
        }, 
        {
            "location": "/spec/#module-declarations", 
            "text": "To safely and effectively use a large library, you or someone else might need to write a larger number of type declarations. You can do so using  Type.module :  Type.module('jquery', function () {\n\n  // Names of concrete types must be capitalized\n  let JQueryObject = Type.new()\n    .withPrototype({\n      on: `(String, DomEventHandler) =  jQueryObject`,\n      show: `(String) =  jQueryObject`,\n      hide: `(String) =  jQueryObject`\n    })\n\n  return {\n    _this_: `(String) =  JQueryObject`,\n    ajax: `({ type: String, url: String }) =  Promise(?)`\n  }\n})\n\nvar $ = require('jquery');\n\n$('#app')        //=  JQueryObject\n$('#app').show() //=  JQueryObject\n\n$.ajax({ type: 'GET', url: 'http://api.example.com' })\n  .then(function (data) {\n    $assume `data : Array({ name: String })` // Annotate your boundary!\n    return data.map( p =  p.name )\n  })", 
            "title": "Module Declarations"
        }, 
        {
            "location": "/type-system/", 
            "text": "Type System\n\n\nThis page aims to document the current set of \nideas\n for the type system. JS Zero is early in its design phase, so expect this page to be in flux.\n\n\nTo reiterate, \neverything on this page is up for discussion.\n\n\nIntersection Types\n\n\nIntersection types\n seems to be the best way to express a type system for JavaScript. This is because everything in JavaScript is an object, \nin addition\n to its own type (e.g. a function is also an object).\n\n\nLibrary writers often take advantage of this fact. For example, jQuery's global variable is both a function and an object:\n\n\n$('button');\n$.ajax({ type: 'GET', url: 'http://api.example.com' });\n\n\n\n\nWith intersection types, you can express this relationship by intersecting two completely different types. For example:\n\n\nlet JQueryObject   = Type.new(...)\nlet JQueryDeferred = Type.new(...)\n\n$assume(`\n  $ : (String) =\n JQueryObject\n    \n { ajax: (Object) =\n JQueryDeferred }\n`)\n\n$('button'); //=\n JQueryObject\n$.ajax({ type: 'GET', url: 'http://api.example.com' }); //=\n JQueryDeferred\n\n\n\n\nBoth \nFlowtype\n and \nTypeScript\n have intersection types as a feature.\n\n\nPrimitive types\n\n\n\n\nBooleans\n\n\nNumbers\n\n\nStrings\n\n\nObjects\n\n\nArrays\n\n\nMaps\n\n\nSets\n\n\nFunctions\n\n\n\n\nPrototypes\n\n\nA core feature of JavaScript is that every type has a inherited prototype of methods. Any value of a type can call that type's prototype methods.\n\n\nThe most useful case of this is when working with arrays:\n\n\nvar data = [10,20,30];\ndata.map(x =\n x * 2).reduce(add);\n\nfunction add (x, y) { return x + y; }\n\n\n\n\nBecause \ndata\n has type \nArray\n, it can call any methods on \nArray.prototype\n. The type system is aware of this and allows \ndata\n to run both the \nmap\n and \nreduce\n methods.\n\n\nIf we were to manually declare part of the \nArray\n type, it might look something like this:\n\n\n// TODO: API design needs works\n$assume `Array.prototype : |v| {\n\n  map: ((v) =\n v2) =\n v2,\n\n  reduce: ((v, v) =\n v2) =\n v2\n        \n ((acc, v) =\n acc, acc) =\n acc\n}\n`", 
            "title": "Type system"
        }, 
        {
            "location": "/type-system/#type-system", 
            "text": "This page aims to document the current set of  ideas  for the type system. JS Zero is early in its design phase, so expect this page to be in flux.  To reiterate,  everything on this page is up for discussion.", 
            "title": "Type System"
        }, 
        {
            "location": "/type-system/#intersection-types", 
            "text": "Intersection types  seems to be the best way to express a type system for JavaScript. This is because everything in JavaScript is an object,  in addition  to its own type (e.g. a function is also an object).  Library writers often take advantage of this fact. For example, jQuery's global variable is both a function and an object:  $('button');\n$.ajax({ type: 'GET', url: 'http://api.example.com' });  With intersection types, you can express this relationship by intersecting two completely different types. For example:  let JQueryObject   = Type.new(...)\nlet JQueryDeferred = Type.new(...)\n\n$assume(`\n  $ : (String) =  JQueryObject\n      { ajax: (Object) =  JQueryDeferred }\n`)\n\n$('button'); //=  JQueryObject\n$.ajax({ type: 'GET', url: 'http://api.example.com' }); //=  JQueryDeferred  Both  Flowtype  and  TypeScript  have intersection types as a feature.", 
            "title": "Intersection Types"
        }, 
        {
            "location": "/type-system/#primitive-types", 
            "text": "Booleans  Numbers  Strings  Objects  Arrays  Maps  Sets  Functions", 
            "title": "Primitive types"
        }, 
        {
            "location": "/type-system/#prototypes", 
            "text": "A core feature of JavaScript is that every type has a inherited prototype of methods. Any value of a type can call that type's prototype methods.  The most useful case of this is when working with arrays:  var data = [10,20,30];\ndata.map(x =  x * 2).reduce(add);\n\nfunction add (x, y) { return x + y; }  Because  data  has type  Array , it can call any methods on  Array.prototype . The type system is aware of this and allows  data  to run both the  map  and  reduce  methods.  If we were to manually declare part of the  Array  type, it might look something like this:  // TODO: API design needs works\n$assume `Array.prototype : |v| {\n\n  map: ((v) =  v2) =  v2,\n\n  reduce: ((v, v) =  v2) =  v2\n          ((acc, v) =  acc, acc) =  acc\n}\n`", 
            "title": "Prototypes"
        }
    ]
}