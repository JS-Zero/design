{
    "docs": [
        {
            "location": "/", 
            "text": "Zero bugs, Zero hassle.\n\n\nCurrent Status: Design phase. We need your input!\n\n\nJavaScript is getting more and more popular every day. However, the dynamic aspect of JavaScript often makes it difficult to correctly write and maintain complex applications.\n\n\nMany efforts have been made to create new, safter languages that compile \nto\n JavaScript. While many of these languages are designed very well, the fact is \nmost people already know JavaScript\n, and are not so inclined to learn a new language to do the same things JavaScript can do.\n\n\nJS Zero\n is a \nES6-compatible, proper subset\n of JavaScript that aims to be functional and type-safe for doing I/O in web applications. \n[Discuss this point]\n\n\nWhy JS Zero?\n\n\n\n\u2009\u2009+--------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+---------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+--------------+\n\u2009\u2009|\u2009\u2009Input\u2009\u2009     |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009 JS Zero      |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009Output\u2009    \u2009|\n\u2009\u2009|  (HTTP)\u2009 \u2009  \u2009|------\n\u2009|\u2009 (Valid ES6)  |------\n\u2009|  (JSON\u2009API)  |\n\u2009\u2009|\u2009\u2009(Database)\u2009\u2009|\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009(type safe)\u2009 |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009(HTML)\u2009\u2009    |\n\u2009\u2009+--------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+---------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+--------------+\n\n\n\n\n\nMuch of programming in web development today is \n\"data in, data out\"\n. That is, given some data sources, we write programs to combine / aggregate / transform that data, then output the result.\n\n\nJavaScript Zero fills this niche; it tries to make writing such programs bug-free, using a \ncompatible subset\n of the ubiquitous language of the web.\n\n\nVision \n Goals\n\n\nJS Zero has three main goals:\n\n\n\n\nSpecify a stricter, ES6-compatible, proper subset of JavaScript\n\n\nDesign and build a type system that can type check this subset soundly\n\n\nAs a developer tool, remain easy and seamless to use and understand.\n\n\n\n\n[Discuss this topic]\n\n\nWith these goals complete, JS Zero will help you significantly towards writing bug-free programs.\n\n\nMotivating Example\n\n\n[Discuss this example]\n\n\nLet's pretend you're making an app that allows a user to enter their \nGitHub username\n and receive back the \ntotal number of lines\n written across their repositories. This will involve using \nGitHub's API\n.\n\n\nAt this point, JS Zero already provides \na key feature\n to help us:\n\n\n\n\nWe must \ndeclare the types\n of the data we will get from the GitHub API. This is a reasonable requirement, since there is no way JS Zero can infer what kind of data GitHub will return.\n\n\n\n\nBecause JS Zero must be valid JavaScript, we must declare these types \nin comments\n. Here is what type declarations for the above example would like (notice the \n@\n symbols):\n\n\n// Although GitHub returns much more data,\n// we only need to declare the types of data we care about.\n//\n// @type Repo = { id: Number, name: String, languages_url: String }\n// @type Languages = Map(String, Number)\n\n\n\n\nAs mentioned, the type of an API request cannot be inferred. That's ok; we can tell JS Zero to \nassume\n the type of a function instead of type checking the function's body. This means JS Zero will \ntrust\n that our type declaration is correct.\n\n\nIn our example, we tell JS Zero to \n@assume\n specific types for our API calls:\n\n\n// @assume fetchRepos : (String) =\n Promise(Array(Repo), HttpError)\nfunction fetchRepos (user) {\n  // Pretend `HTTP` is a library that returns a promise\n  return HTTP.get('http://api.github.com/users/' + user + '/repos');\n}\n\n// @assume fetchLangs : (String) =\n Promise(Languages, HttpError)\nfunction fetchLangs (languages_url) {\n\n  return HTTP.get(languages_url).then(function(langs) {\n    // Be careful! The above `@assume` means no type checking will be done for this code.\n    var keyValPairs = Object.keys(langs).map( k =\n [k, langs[k]] );\n    return new Map(keyValPairs);\n  })\n}\n\n\n\n\nNow that we've declared the types of our HTTP requests, we can \nsafely\n make use of them:\n\n\n// Note how there are NO TYPE DECLARATIONS in the following code!\n\nmyFormElement.addEventListener('submit', function(e) {\n  e.preventDefault();\n\n  fetchRepo(this.githubUsername.value)\n\n    .then(function(repos) {\n      // This line doesn't type check - r.language_url is not a property!\n      // var promises = repos.map(r =\n fetchLangs(r.language_url));\n\n      var promises = repos.map(r =\n fetchLangs(r.languages_url));\n      return Promise.all(promises);\n    })\n\n    .then(function(repoLanguages) {\n      // At this point, `repoLanguages` is an Array of Languages.\n      // In other words, it has the type Array( Map(String, Number) ).\n      // If that slipped by you, no problem. JS Zero has got you covered.\n\n      var totalLineCount = repoLanguages\n                           .map(langs =\n langs.values().reduce(add))\n                           .reduce(add)\n      ;\n      alert(\nYou have written \n + totalLineCount + \n lines of code!\n);\n    })\n  ;\n});\n\nfunction add (x, y) { return x + y; }\n\n\n\n\n[Discuss this example]\n\n\nAs you can see, once you annotate your boundaries (HTTP in this case), no further type declarations are necessary. The idea is, you record the shape of your data once, and then safely forget about it.\n\n\nIntegrating with Other JS Code\n\n\n[Discuss this topic]\n\n\nAlthough all JS Zero code is valid JavaScript code, not all JavaScript code is valid Zero code. If you want your code to be type safe, sometimes you will have to annotate 3rd party libraries.\n\n\nAs it turns out, \n@assume\n is an easy way to do this if you only need a function or two. For example, let's say you want to use the \nmarked\n npm package to render some markdown:\n\n\n// @assume marked : (String) =\n String\nvar marked = require('marked');\nconsole.log( marked('I am using __markdown__.') );\n\n\n\n\nOn the other hand, if you're importing a larger library, you might need to write annotations yourself (assuming someone else has not already). For example, if you want to use \nReact.js\n to handle your views, the type declarations might look something like this:\n\n\n/*\n@module React 'react' {\n  @newtype VirtualElement;\n  @type Attrs = Object | Null;\n  @type Child = String | VirtualElement;\n\n  createElement : (String) =\n VirtualElement;\n  createElement : (String, Attrs) =\n VirtualElement;\n  createElement : (String, Attrs, Child...) =\n VirtualElement;\n  render : (VirtualElement, DomElement) =\n Void;\n}\n*/\nvar React = require('react');\n\n// All type safe!\nReact.render(\n  React.createElement('h1', null, 'Hello, world!'),\n  document.getElementById('.my-div')\n);\n\n\n\n\n[Discuss JS code integration]\n\n\nInterested?\n\n\nJS Zero is only in its design phase. If you find JS Zero interesting, we would love to have your valuable input!\n\n\nSee all discussion topics here.", 
            "title": "Home"
        }, 
        {
            "location": "/#zero-bugs-zero-hassle", 
            "text": "Current Status: Design phase. We need your input!  JavaScript is getting more and more popular every day. However, the dynamic aspect of JavaScript often makes it difficult to correctly write and maintain complex applications.  Many efforts have been made to create new, safter languages that compile  to  JavaScript. While many of these languages are designed very well, the fact is  most people already know JavaScript , and are not so inclined to learn a new language to do the same things JavaScript can do.  JS Zero  is a  ES6-compatible, proper subset  of JavaScript that aims to be functional and type-safe for doing I/O in web applications.  [Discuss this point]", 
            "title": "Zero bugs, Zero hassle."
        }, 
        {
            "location": "/#why-js-zero", 
            "text": "+--------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+---------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+--------------+\n\u2009\u2009|\u2009\u2009Input\u2009\u2009     |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009 JS Zero      |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009Output\u2009    \u2009|\n\u2009\u2009|  (HTTP)\u2009 \u2009  \u2009|------ \u2009|\u2009 (Valid ES6)  |------ \u2009|  (JSON\u2009API)  |\n\u2009\u2009|\u2009\u2009(Database)\u2009\u2009|\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009(type safe)\u2009 |\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009|\u2009\u2009(HTML)\u2009\u2009    |\n\u2009\u2009+--------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+---------------+\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009+--------------+  Much of programming in web development today is  \"data in, data out\" . That is, given some data sources, we write programs to combine / aggregate / transform that data, then output the result.  JavaScript Zero fills this niche; it tries to make writing such programs bug-free, using a  compatible subset  of the ubiquitous language of the web.", 
            "title": "Why JS Zero?"
        }, 
        {
            "location": "/#vision-goals", 
            "text": "JS Zero has three main goals:   Specify a stricter, ES6-compatible, proper subset of JavaScript  Design and build a type system that can type check this subset soundly  As a developer tool, remain easy and seamless to use and understand.   [Discuss this topic]  With these goals complete, JS Zero will help you significantly towards writing bug-free programs.", 
            "title": "Vision &amp; Goals"
        }, 
        {
            "location": "/#motivating-example", 
            "text": "[Discuss this example]  Let's pretend you're making an app that allows a user to enter their  GitHub username  and receive back the  total number of lines  written across their repositories. This will involve using  GitHub's API .  At this point, JS Zero already provides  a key feature  to help us:   We must  declare the types  of the data we will get from the GitHub API. This is a reasonable requirement, since there is no way JS Zero can infer what kind of data GitHub will return.   Because JS Zero must be valid JavaScript, we must declare these types  in comments . Here is what type declarations for the above example would like (notice the  @  symbols):  // Although GitHub returns much more data,\n// we only need to declare the types of data we care about.\n//\n// @type Repo = { id: Number, name: String, languages_url: String }\n// @type Languages = Map(String, Number)  As mentioned, the type of an API request cannot be inferred. That's ok; we can tell JS Zero to  assume  the type of a function instead of type checking the function's body. This means JS Zero will  trust  that our type declaration is correct.  In our example, we tell JS Zero to  @assume  specific types for our API calls:  // @assume fetchRepos : (String) =  Promise(Array(Repo), HttpError)\nfunction fetchRepos (user) {\n  // Pretend `HTTP` is a library that returns a promise\n  return HTTP.get('http://api.github.com/users/' + user + '/repos');\n}\n\n// @assume fetchLangs : (String) =  Promise(Languages, HttpError)\nfunction fetchLangs (languages_url) {\n\n  return HTTP.get(languages_url).then(function(langs) {\n    // Be careful! The above `@assume` means no type checking will be done for this code.\n    var keyValPairs = Object.keys(langs).map( k =  [k, langs[k]] );\n    return new Map(keyValPairs);\n  })\n}  Now that we've declared the types of our HTTP requests, we can  safely  make use of them:  // Note how there are NO TYPE DECLARATIONS in the following code!\n\nmyFormElement.addEventListener('submit', function(e) {\n  e.preventDefault();\n\n  fetchRepo(this.githubUsername.value)\n\n    .then(function(repos) {\n      // This line doesn't type check - r.language_url is not a property!\n      // var promises = repos.map(r =  fetchLangs(r.language_url));\n\n      var promises = repos.map(r =  fetchLangs(r.languages_url));\n      return Promise.all(promises);\n    })\n\n    .then(function(repoLanguages) {\n      // At this point, `repoLanguages` is an Array of Languages.\n      // In other words, it has the type Array( Map(String, Number) ).\n      // If that slipped by you, no problem. JS Zero has got you covered.\n\n      var totalLineCount = repoLanguages\n                           .map(langs =  langs.values().reduce(add))\n                           .reduce(add)\n      ;\n      alert( You have written   + totalLineCount +   lines of code! );\n    })\n  ;\n});\n\nfunction add (x, y) { return x + y; }  [Discuss this example]  As you can see, once you annotate your boundaries (HTTP in this case), no further type declarations are necessary. The idea is, you record the shape of your data once, and then safely forget about it.", 
            "title": "Motivating Example"
        }, 
        {
            "location": "/#integrating-with-other-js-code", 
            "text": "[Discuss this topic]  Although all JS Zero code is valid JavaScript code, not all JavaScript code is valid Zero code. If you want your code to be type safe, sometimes you will have to annotate 3rd party libraries.  As it turns out,  @assume  is an easy way to do this if you only need a function or two. For example, let's say you want to use the  marked  npm package to render some markdown:  // @assume marked : (String) =  String\nvar marked = require('marked');\nconsole.log( marked('I am using __markdown__.') );  On the other hand, if you're importing a larger library, you might need to write annotations yourself (assuming someone else has not already). For example, if you want to use  React.js  to handle your views, the type declarations might look something like this:  /*\n@module React 'react' {\n  @newtype VirtualElement;\n  @type Attrs = Object | Null;\n  @type Child = String | VirtualElement;\n\n  createElement : (String) =  VirtualElement;\n  createElement : (String, Attrs) =  VirtualElement;\n  createElement : (String, Attrs, Child...) =  VirtualElement;\n  render : (VirtualElement, DomElement) =  Void;\n}\n*/\nvar React = require('react');\n\n// All type safe!\nReact.render(\n  React.createElement('h1', null, 'Hello, world!'),\n  document.getElementById('.my-div')\n);  [Discuss JS code integration]", 
            "title": "Integrating with Other JS Code"
        }, 
        {
            "location": "/#interested", 
            "text": "JS Zero is only in its design phase. If you find JS Zero interesting, we would love to have your valuable input!  See all discussion topics here.", 
            "title": "Interested?"
        }, 
        {
            "location": "/FAQ/", 
            "text": "FAQ\n\n\nHow does JS Zero differ from TypeScript?\n\n\nTypeScript aims to be a \nsuperset\n of JavaScript, while JS Zero aims to be a \nsubset\n. This means TypeScript \nextends\n the JS language, while JS Zero \nrefines\n the language by removing features that are hard to check for correctness.\n\n\nHow does JS Zero differ from Flowtype?\n\n\nFlowtype and JS Zero are indeed very similar. However, Flowtype aims to type check the \nentire JavaScript language\n. Unfortunately, JavaScript as a whole is too dynamic for Flowtype to achieve full type safety. JS Zero aims to specify a \nsubset\n of JavaScript that can be type checked \nsoundly\n.", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/FAQ/#how-does-js-zero-differ-from-typescript", 
            "text": "TypeScript aims to be a  superset  of JavaScript, while JS Zero aims to be a  subset . This means TypeScript  extends  the JS language, while JS Zero  refines  the language by removing features that are hard to check for correctness.", 
            "title": "How does JS Zero differ from TypeScript?"
        }, 
        {
            "location": "/FAQ/#how-does-js-zero-differ-from-flowtype", 
            "text": "Flowtype and JS Zero are indeed very similar. However, Flowtype aims to type check the  entire JavaScript language . Unfortunately, JavaScript as a whole is too dynamic for Flowtype to achieve full type safety. JS Zero aims to specify a  subset  of JavaScript that can be type checked  soundly .", 
            "title": "How does JS Zero differ from Flowtype?"
        }, 
        {
            "location": "/examples/", 
            "text": "Motivating Examples\n\n\nSimple Array of Models\n\n\n// @type Person = { name: String, age: Number }\n\n// @assume fetchPeople : () =\n Promise(Array(Person), HttpError)\nfunction fetchPeople () {\n  return HTTP.get('http://api.example.com/people');\n}\n\n// Here we safely use fetchPeople without the need for further type annotations.\nfetchPeople()\n  .then(function(people) {\n    var names = people.map(p =\n p.name);\n    var ageSum = people.map(p =\n p.age).reduce(add);\n\n    // Won't pass: Person has no `hobby` property\n    // var hobbies = people.map(p =\n p.hobby);\n\n    // Creating an array in this fashion indicates a Tuple type.\n    return Array(names.length, ageSum);\n  })\n  .then(function([nameCount, ageSum]) {\n    console.log(\n# of names:\n, nameCount);\n    console.log(\nSum of ages:\n, ageSum);\n\n    // Won't pass: number is not a function\n    // ageSum()\n  });\n\nfunction add (x, y) { return x + y }", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#motivating-examples", 
            "text": "", 
            "title": "Motivating Examples"
        }, 
        {
            "location": "/examples/#simple-array-of-models", 
            "text": "// @type Person = { name: String, age: Number }\n\n// @assume fetchPeople : () =  Promise(Array(Person), HttpError)\nfunction fetchPeople () {\n  return HTTP.get('http://api.example.com/people');\n}\n\n// Here we safely use fetchPeople without the need for further type annotations.\nfetchPeople()\n  .then(function(people) {\n    var names = people.map(p =  p.name);\n    var ageSum = people.map(p =  p.age).reduce(add);\n\n    // Won't pass: Person has no `hobby` property\n    // var hobbies = people.map(p =  p.hobby);\n\n    // Creating an array in this fashion indicates a Tuple type.\n    return Array(names.length, ageSum);\n  })\n  .then(function([nameCount, ageSum]) {\n    console.log( # of names: , nameCount);\n    console.log( Sum of ages: , ageSum);\n\n    // Won't pass: number is not a function\n    // ageSum()\n  });\n\nfunction add (x, y) { return x + y }", 
            "title": "Simple Array of Models"
        }, 
        {
            "location": "/spec/", 
            "text": "Specification\n\n\nThis document specifies exactly what parts of ES6 will be included in the JS Zero subset, as well as type declaration syntax and usage.\n\n\nThis is a \nvery\n rough draft. Please see discussion threads for latest details.\n\n\nGoals\n\n\n\n\nStay close to primitive types\n\n\nObjects, arrays, functions, strings, numbers, booleans, maps, and sets should cover almost all use cases.\n\n\nOnly require type annotations at \nboundaries\n\n\nDatabase queries, HTTP requests, etc.\n\n\n\n\n[Discuss these goals]\n\n\nAnti-Goals\n\n\nHere are some things JS Zero is NOT trying to do:\n\n\n\n\nChange the existing behavior of JavaScript\n\n\nExplanation: If something doesn't fit, it should be \nremoved\n (but never changed)\n\n\nForce all code to be \npure\n\n\nExplanation: JavaScript is not designed to be a pure language. Forcing it to be so would not be worth the effort.\n\n\nRequire knowledge of advanced type-theory to effectively use JS Zero\n\n\nExplanation: JS Zero is designed to be used by the average JavaScript developer.\n\n\n\n\n[Discuss these anti-goals]\n\n\nSpecific Features\n\n\n(incomplete) This is the subset of features you will be able to write in JavaScript Zero:\n\n\n\n\nlet, var, const\n\n\nBasic types (objects, arrays, strings, numbers, booleans)\n\n\nFunctions - anonymous, declarations, arrow\n\n\nSymbols\n\n\nPromises\n\n\nMap / Set\n\n\nPrototypes\n\n\n\n\nThese features will be \nomitted\n:\n\n\n\n\nNo classes, no keyword \nnew\n\n\nNo double equals \n==\n\n\n\n\n[Discuss this subset of features]\n\n\nTypes and Type Declarations\n\n\nType declarations are written in comments to keep JS Zero ES6-compatible.\n\n\n[Discuss type declarations]\n\n\nType Aliases\n\n\nTo declare a type alias, use the \n@type\n declaration. This creates an alias that is no different than the type you set it to.\n\n\n// @type Venue = { name: String, rating: Number }\n\n\n\n\nAssumptions\n\n\nWhen working with IO, many times you will be reading data from some external source. In these cases you don't want JS Zero to attempt (and fail) at determining your types. Instead, you want to use \n@assume\n to explicitly declare what types your incoming data will be.\n\n\n// @type Pet = { name: String, happiness: Number }\n\n// @assume fetchPets : (Number) =\n Array(Pet)\nfunction fetchPets (minHappiness) {\n  return knex.select('*').from('pets').where('happiness', '\n', minHappiness)\n}\n\n\n\n\nNew Types\n\n\nTo declare an entirely new type, use the \n@newtype\n declaration. This is useful for creating opaque types when declaring modules (explained in the next section).\n\n\nFor example, here is how you create an opaque type:\n\n\n// @newtype VirtualElement\n// @assume React.render : (String, Object) =\n VirtualElement\n\n\n\n\nA new type is only considered equal to itself, even if its structure is the same as another type's structure. For example:\n\n\n// @type Person = { name: String }\n// @type Book   = { name: String }\n\n// @newtype Person2 = { name: String }\n\n\n\n\nEven though \nPerson\n and \nPerson2\n are structurally the same, they are not considered equal. In contrast, type \nPerson\n and \nBook\n are both type \naliases\n, and thus considered the same type.\n\n\nModule Declarations\n\n\nTo safely and effectively use a large library, you or someone else might need to write a larger number of type declarations. You can do so using the \n@module\n block comment:\n\n\n/*\n@module JQuery 'jquery' {\n  @newtype Wrapper = {\n    on: (String, DomEventHandler) =\n Wrapper,\n    show: (String) =\n Wrapper,\n    hide: (String) =\n Wrapper\n  }\n\n  @newtype Deferred(value) = {\n    then: ((value) =\n newValue) =\n Deferred(newValue)\n  }\n\n  this : (String) =\n Wrapper;\n}\n*/\nvar $ = require('jquery');\n\n\n\n\nIn the above example, the \nJQuery\n part of \n@module JQuery\n is the name of the type, while the [optional] \n'jquery'\n part is the string name you pass into \nrequire\n.\n\n\n[Discuss type declarations]", 
            "title": "Spec"
        }, 
        {
            "location": "/spec/#specification", 
            "text": "This document specifies exactly what parts of ES6 will be included in the JS Zero subset, as well as type declaration syntax and usage.  This is a  very  rough draft. Please see discussion threads for latest details.", 
            "title": "Specification"
        }, 
        {
            "location": "/spec/#goals", 
            "text": "Stay close to primitive types  Objects, arrays, functions, strings, numbers, booleans, maps, and sets should cover almost all use cases.  Only require type annotations at  boundaries  Database queries, HTTP requests, etc.   [Discuss these goals]", 
            "title": "Goals"
        }, 
        {
            "location": "/spec/#anti-goals", 
            "text": "Here are some things JS Zero is NOT trying to do:   Change the existing behavior of JavaScript  Explanation: If something doesn't fit, it should be  removed  (but never changed)  Force all code to be  pure  Explanation: JavaScript is not designed to be a pure language. Forcing it to be so would not be worth the effort.  Require knowledge of advanced type-theory to effectively use JS Zero  Explanation: JS Zero is designed to be used by the average JavaScript developer.   [Discuss these anti-goals]", 
            "title": "Anti-Goals"
        }, 
        {
            "location": "/spec/#specific-features", 
            "text": "(incomplete) This is the subset of features you will be able to write in JavaScript Zero:   let, var, const  Basic types (objects, arrays, strings, numbers, booleans)  Functions - anonymous, declarations, arrow  Symbols  Promises  Map / Set  Prototypes   These features will be  omitted :   No classes, no keyword  new  No double equals  ==   [Discuss this subset of features]", 
            "title": "Specific Features"
        }, 
        {
            "location": "/spec/#types-and-type-declarations", 
            "text": "Type declarations are written in comments to keep JS Zero ES6-compatible.  [Discuss type declarations]  Type Aliases  To declare a type alias, use the  @type  declaration. This creates an alias that is no different than the type you set it to.  // @type Venue = { name: String, rating: Number }  Assumptions  When working with IO, many times you will be reading data from some external source. In these cases you don't want JS Zero to attempt (and fail) at determining your types. Instead, you want to use  @assume  to explicitly declare what types your incoming data will be.  // @type Pet = { name: String, happiness: Number }\n\n// @assume fetchPets : (Number) =  Array(Pet)\nfunction fetchPets (minHappiness) {\n  return knex.select('*').from('pets').where('happiness', ' ', minHappiness)\n}  New Types  To declare an entirely new type, use the  @newtype  declaration. This is useful for creating opaque types when declaring modules (explained in the next section).  For example, here is how you create an opaque type:  // @newtype VirtualElement\n// @assume React.render : (String, Object) =  VirtualElement  A new type is only considered equal to itself, even if its structure is the same as another type's structure. For example:  // @type Person = { name: String }\n// @type Book   = { name: String }\n\n// @newtype Person2 = { name: String }  Even though  Person  and  Person2  are structurally the same, they are not considered equal. In contrast, type  Person  and  Book  are both type  aliases , and thus considered the same type.  Module Declarations  To safely and effectively use a large library, you or someone else might need to write a larger number of type declarations. You can do so using the  @module  block comment:  /*\n@module JQuery 'jquery' {\n  @newtype Wrapper = {\n    on: (String, DomEventHandler) =  Wrapper,\n    show: (String) =  Wrapper,\n    hide: (String) =  Wrapper\n  }\n\n  @newtype Deferred(value) = {\n    then: ((value) =  newValue) =  Deferred(newValue)\n  }\n\n  this : (String) =  Wrapper;\n}\n*/\nvar $ = require('jquery');  In the above example, the  JQuery  part of  @module JQuery  is the name of the type, while the [optional]  'jquery'  part is the string name you pass into  require .  [Discuss type declarations]", 
            "title": "Types and Type Declarations"
        }, 
        {
            "location": "/type-system/", 
            "text": "Type System\n\n\nThis page aims to document the current set of \nideas\n for the type system. JS Zero is early in its design phase, so expect this page to be in flux.\n\n\nTo reiterate, \neverything on this page is up for discussion.\n\n\nIntersection Types\n\n\nIntersection types\n seems to be the best way to express a type system for JavaScript. This is because everything in JavaScript is an object, \nin addition\n to its own type (e.g. a function is also an object).\n\n\nLibrary writers often take advantage of this fact. For example, jQuery's global variable is both a function and an object:\n\n\n$('button');\n$.ajax({ type: 'GET', url: 'http://api.example.com' });\n\n\n\n\nWith intersection types, you can express this relationship by intersecting two completely different types. For example:\n\n\n// @type JQueryCallable = (String) =\n JQueryObject\n// @type JQueryAjax     = { ajax: (Object) =\n JQueryDeferred }\n\n// @assume $ : JQueryCallable \n JQueryAjax\n$('button');\n$.ajax({ type: 'GET', url: 'http://api.example.com' });\n\n\n\n\nBoth \nFlowtype\n and \nTypeScript\n have intersection types as a feature.\n\n\n[Discuss intersection types]\n\n\nPrimitive types\n\n\n\n\nBooleans\n\n\nNumbers\n\n\nStrings\n\n\nObjects\n\n\nArrays\n\n\nMaps\n\n\nSets\n\n\nFunctions\n\n\n\n\nPrototypes\n\n\nA core feature of JavaScript is that every type has a inherited prototype of methods. Any value of a type can call that type's prototype methods.\n\n\nThe most useful case of this is when working with arrays:\n\n\nvar data = [10,20,30];\ndata.map(x =\n x * 2).reduce(add);\n\nfunction add (x, y) { return x + y; }\n\n\n\n\nBecause \ndata\n has type \nArray\n, it can call any methods on \nArray.prototype\n. The type system is aware of this and allows \ndata\n to run both the \nmap\n and \nreduce\n methods.\n\n\nIf we were to manually declare part of the \nArray\n type, it might look something like this:\n\n\n/*\n@newtype Array(t);\n@assume  Array(t).prototype : {\n  map:    ((t) =\n returnType) =\n Array(returnType),\n  reduce: ((t, t) =\n t) =\n t,\n  reduce: ((acc, t) =\n acc, acc) =\n acc\n};\n*/\n\n\n\n\nImplementation Approach (idea)\n\n\nAt first, the type system will not have the responsibility of inferring prototype methods. Instead, we will annotate the primitive types manually. The idea is we encourage developers to use primitives as much as possible, and use plain functions when creating their own data structures. If necessary, and if possible, we can add prototype inference later.\n\n\n[Discuss typing prototypes]", 
            "title": "Type system"
        }, 
        {
            "location": "/type-system/#type-system", 
            "text": "This page aims to document the current set of  ideas  for the type system. JS Zero is early in its design phase, so expect this page to be in flux.  To reiterate,  everything on this page is up for discussion.", 
            "title": "Type System"
        }, 
        {
            "location": "/type-system/#intersection-types", 
            "text": "Intersection types  seems to be the best way to express a type system for JavaScript. This is because everything in JavaScript is an object,  in addition  to its own type (e.g. a function is also an object).  Library writers often take advantage of this fact. For example, jQuery's global variable is both a function and an object:  $('button');\n$.ajax({ type: 'GET', url: 'http://api.example.com' });  With intersection types, you can express this relationship by intersecting two completely different types. For example:  // @type JQueryCallable = (String) =  JQueryObject\n// @type JQueryAjax     = { ajax: (Object) =  JQueryDeferred }\n\n// @assume $ : JQueryCallable   JQueryAjax\n$('button');\n$.ajax({ type: 'GET', url: 'http://api.example.com' });  Both  Flowtype  and  TypeScript  have intersection types as a feature.  [Discuss intersection types]", 
            "title": "Intersection Types"
        }, 
        {
            "location": "/type-system/#primitive-types", 
            "text": "Booleans  Numbers  Strings  Objects  Arrays  Maps  Sets  Functions", 
            "title": "Primitive types"
        }, 
        {
            "location": "/type-system/#prototypes", 
            "text": "A core feature of JavaScript is that every type has a inherited prototype of methods. Any value of a type can call that type's prototype methods.  The most useful case of this is when working with arrays:  var data = [10,20,30];\ndata.map(x =  x * 2).reduce(add);\n\nfunction add (x, y) { return x + y; }  Because  data  has type  Array , it can call any methods on  Array.prototype . The type system is aware of this and allows  data  to run both the  map  and  reduce  methods.  If we were to manually declare part of the  Array  type, it might look something like this:  /*\n@newtype Array(t);\n@assume  Array(t).prototype : {\n  map:    ((t) =  returnType) =  Array(returnType),\n  reduce: ((t, t) =  t) =  t,\n  reduce: ((acc, t) =  acc, acc) =  acc\n};\n*/  Implementation Approach (idea)  At first, the type system will not have the responsibility of inferring prototype methods. Instead, we will annotate the primitive types manually. The idea is we encourage developers to use primitives as much as possible, and use plain functions when creating their own data structures. If necessary, and if possible, we can add prototype inference later.  [Discuss typing prototypes]", 
            "title": "Prototypes"
        }
    ]
}